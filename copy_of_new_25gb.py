# -*- coding: utf-8 -*-
"""Copy of new_25gb.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CLF9gFKL7h7TPd5ns7NT2glPLLLBCaH4

# New Section
"""

import matplotlib.pyplot as plt
import seaborn as sb
import numpy as np
import pandas as pd
import zipfile
import seaborn as sns


"""from google.colab import drive
drive.mount('/content/drive',force_remount=True)

zf = zipfile.ZipFile('/content/drive/My Drive/ddosat/ddos.zip')
zf.extractall("/tmp")
"""

zf = zipfile.ZipFile('ddos.zip') 
zf.extractall()



import matplotlib.pyplot as plt
import seaborn as sb
import numpy as np
import pandas as pd

d1 = pd.read_csv('01-12/DrDoS_DNS.csv',nrows=200000, low_memory=False)
d1 = d1.sample(n=40000,random_state=24)
d2 = pd.read_csv('01-12/DrDoS_LDAP.csv',nrows=200000, low_memory=False)
d2 = d2.sample(n=40000,random_state=24)
d3 = pd.read_csv('01-12/DrDoS_MSSQL.csv',nrows=200000, low_memory=False)
d3 = d3.sample(n=40000,random_state=24)
d4 = pd.read_csv('01-12/DrDoS_NetBIOS.csv',nrows=200000, low_memory=False)
d4 = d4.sample(n=40000,random_state=24)
d5 = pd.read_csv('01-12/DrDoS_NTP.csv',nrows=200000, low_memory=False)
d5 = d5.sample(n=40000,random_state=24)
d6 = pd.read_csv('01-12/DrDoS_SNMP.csv',nrows=200000, low_memory=False)
d6 = d6.sample(n=40000,random_state=24)
d7 = pd.read_csv('01-12/DrDoS_SSDP.csv',nrows=200000, low_memory=False)
d7 = d7.sample(n=40000,random_state=24)
d8 = pd.read_csv('01-12/DrDoS_UDP.csv',nrows=200000, low_memory=False)
d8 = d8.sample(n=40000,random_state=24)
d9 = pd.read_csv('01-12/Syn.csv',nrows=200000, low_memory=False)
d9 = d9.sample(n=40000,random_state=24)
d10 = pd.read_csv('01-12/TFTP.csv',nrows=200000, low_memory=False)
d10 = d10.sample(n=40000,random_state=24)
d11 = pd.read_csv('01-12/UDPLag.csv',nrows=200000, low_memory=False)
d11 = d11.sample(n=40000,random_state=24)

# df.info()

# df[' Label'].value_counts()

d2.info()

df = pd.concat([d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11])

def Pre_process_data(df,col):
    '''
    Input: Data-frame and Column name.
    Operation: Fills the nan values with the minimum value in their respective column.
    Output: Returns the pre-processed data-frame.
    '''
    #df['primary_use'] = df['primary_use'].astype("category").cat.codes
    print("Name of column with NaN: "+str(col))
    print(df[col].value_counts(dropna=False, normalize=True).head())
    df[col].replace(np.inf, -1, inplace=True)
    
    return df

def reduce_mem_usage(df):
    '''
    Input - data-frame.
    Operation - Reduce memory usage of the data-frame.
    '''
    start_mem_usg = df.memory_usage().sum() / 1024**2 
    print("Memory usage of properties dataframe is :",start_mem_usg," MB")
    #NAlist = [] # Keeps track of columns that have missing values filled in. 
    for col in df.columns:
        if df[col].dtype != object:  # Exclude strings            
            # Print current column type
            print("******************************")
            print("Column: ",col)
            print("dtype before: ",df[col].dtype)            
            # make variables for Int, max and min
            IsInt = False
            mx = df[col].max()
            mn = df[col].min()
            #print("min for this col: ",mn)
            #print("max for this col: ",mx)
            # Integer does not support NA, therefore, NA needs to be filled
            if not np.isfinite(df[col]).all(): 
                #NAlist.append(col)
                df = Pre_process_data(df,col)
                   
            # test if column can be converted to an integer
            asint = df[col].fillna(0).astype(np.int64)
            result = (df[col] - asint)
            result = result.sum()
            if result > -0.01 and result < 0.01:
                IsInt = True            
            # Make Integer/unsigned Integer datatypes
            if IsInt:
                if mn >= 0:
                    if mx < 255:
                        df[col] = df[col].astype(np.uint8)
                    elif mx < 65535:
                        df[col] = df[col].astype(np.uint16)
                    elif mx < 4294967295:
                        df[col] = df[col].astype(np.uint32)
                    else:
                        df[col] = df[col].astype(np.uint64)
                else:
                    if mn > np.iinfo(np.int8).min and mx < np.iinfo(np.int8).max:
                        df[col] = df[col].astype(np.int8)
                    elif mn > np.iinfo(np.int16).min and mx < np.iinfo(np.int16).max:
                        df[col] = df[col].astype(np.int16)
                    elif mn > np.iinfo(np.int32).min and mx < np.iinfo(np.int32).max:
                        df[col] = df[col].astype(np.int32)
                    elif mn > np.iinfo(np.int64).min and mx < np.iinfo(np.int64).max:
                        df[col] = df[col].astype(np.int64)    
            # Make float datatypes 32 bit
            else:
                df[col] = df[col].astype(np.float32)
            
            # Print new column type
            print("dtype after: ",df[col].dtype)
            print("******************************")
    # Print final result
    print("___MEMORY USAGE AFTER COMPLETION:___")
    mem_usg = df.memory_usage().sum() / 1024**2 
    print("Memory usage is: ",mem_usg," MB")
    print("This is ",100*mem_usg/start_mem_usg,"% of the initial size")
    return df

df = reduce_mem_usage(df)

data_ = df
df[' Label'].value_counts()

labels = 'Syn', 'DrDoS_SNMP','DrDoS_LDAP','DrDoS_SSDP','DrDoS_NetBIOS','DrDoS_MSSQL','TFTP','DrDoS_UDP','DrDoS_DNS','UDP-lag','DrDoS_NTP','BENIGN','WebDDoS'
sizes = [len(data_[data_[' Label']=='Syn']), len(data_[data_[' Label']=='DrDoS_SNMP']), 
         len(data_[data_[' Label']=='DrDoS_LDAP']), len(data_[data_[' Label']=='DrDoS_SSDP']),
         len(data_[data_[' Label']=='DrDoS_NetBIOS']),len(data_[data_[' Label']=='DrDoS_MSSQL']),
         len(data_[data_[' Label']=='TFTP']),
         len(data_[data_[' Label']=='DrDoS_UDP']),len(data_[data_[' Label']=='DrDoS_DNS']),len(data_[data_[' Label']=='UDP-lag']),len(data_[data_[' Label']=='DrDoS_NTP']),len(data_[data_[' Label']=='BENIGN']),
         len(data_[data_[' Label']=='WebDDoS'])]
colors = ['gold', 'yellowgreen', 'lightcoral', 'lightskyblue','yellow','purple','grey','indigo','orange','black','violet','magenta','white']
explode = (0.3, 0.1, 0.1, 0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.3,0.2,0.1)  # explode 1st slice

# Plot
plt.rcParams.update({'font.size': 22})
plt.figure(figsize=(10,10))
plt.pie(sizes, explode=explode, labels=labels, colors=colors,
autopct='%1.2f%%', shadow=True, startangle=140)

plt.axis('equal')
plt.show()

plt.figure(figsize=(40,20))
g1 = sns.countplot(x=' Label', hue=' Label', data=data_)
gt = g1.twinx()
gt = sns.pointplot(y=' Flow Packets/s', x=' Label', data=data_, color='black', legend=True)
gt.set_ylabel(" Flow Packets/s", fontsize=16)

plt.figure(figsize=(20,16))
g1 = sns.countplot(x=' Label', hue=' Label', data=data_)
gt = g1.twinx()
gt = sns.pointplot(y='Flow Bytes/s', x=' Label', data=data_, color='black', legend=False)
gt.set_ylabel("Flow Bytes/s", fontsize=16)

plt.figure(figsize=(40,16))
g1 = sns.scatterplot(y=' Total Fwd Packets', x='Total Length of Fwd Packets',
                     sizes=(200, 400), size=' Flow Duration',data=data_)

gt = g1.twinx()
t = sns.pointplot(y='Fwd Packets/s', x=' Label', data=data_, color='black', legend=False)
gt.set_ylabel("Fwd Packets/s", fontsize=16)

plt.figure(figsize=(40,16))
g1 = sns.scatterplot(y=' Total Backward Packets', x=' Total Length of Bwd Packets',
                     sizes=(200, 400), size=' Flow Duration',data=data_)
gt = g1.twinx()
t = sns.pointplot(y=' Bwd Packets/s', x=' Label', data=data_, color='black', legend=False)
gt.set_ylabel("Bwd Packets/s", fontsize=16)

"""
plt.figure(figsize=(20,16))
g1 = sns.scatterplot(y=' Total Backward Packets', x=' Total Length of Bwd Packets',
                     sizes=(200, 400), size=' Flow Duration',data=data_)
gt = g1.twinx()
t = sns.pointplot(y=' Bwd Packets/s', x=' Label', data=data_, color='black', legend=False)
gt.set_ylabel("Bwd Packets/s", fontsize=16)"""

plt.figure(figsize=(20,16))
g1 = sns.countplot(x=' Label', data=data_,alpha=0.5)
gt = g1.twinx()
gt = sns.countplot(x=' Protocol', hue=' Label',alpha=0.7, data=data_)
gt.set_ylabel(" Protocol", fontsize=16)

plt.figure(figsize=(20,16))
g1 = sns.countplot(x=' Label', data=data_,alpha=0.5)
gt = g1.twinx()
gt = sns.countplot(x=' Inbound', hue=' Label',alpha=0.7, data=data_)
gt.set_ylabel(' Inbound', fontsize=16)

plt.figure(figsize=(40,16))
g1 = sns.countplot(x='SimillarHTTP', hue=' Label',alpha=0.7, data=data_)
gt = g1.twinx()
gt = sns.countplot(x=' Label', data=data_,alpha=0.4)

df.head()

df.columns

df = df.drop(['Flow ID', ' Source IP',' Source Port',' Destination IP',' Destination Port',' Timestamp','Fwd Packets/s','Flow Bytes/s'], axis = 1)

from sklearn.preprocessing import StandardScaler
from sklearn import preprocessing
# X_std = StandardScaler().fit_transform(df)

df = df.drop(['SimillarHTTP'],axis=1)

# y = df[' Label']
# df = df.drop(columns=[' Label'])
X = StandardScaler().fit_transform(df)
X_norm = preprocessing.normalize(X)

from sklearn.decomposition import PCA
pca = PCA(n_components=2) 
principalComponents = pca.fit_transform(X_norm)
plt.figure(figsize=(16,16))
g1 = sns.scatterplot(principalComponents[:, 0], principalComponents[:, 1], s= 100, hue=data_[' Label'], cmap='Spectral',alpha=0.7)
plt.title('Visualizing DDoS attacks through PCA', fontsize=24);

from sklearn.manifold import TSNE
from sklearn.decomposition import PCA
pca_ = PCA(n_components=2) 
principalComponents = pca_.fit_transform(X_norm)
# tsne_ = TSNE(random_state = 42, n_components=2,verbose=0, perplexity=40, n_iter=600).fit_transform(principalComponents)
# plt.figure(figsize=(16,16))
# g1 = sns.scatterplot(tsne_[:, 0], tsne_[:, 1], s= 100, hue=data_[' Label'], cmap='Spectral',alpha=0.7)
# plt.title('Visualizing DDoS attacks through t-SNE', fontsize=24);

from sklearn.cluster import AgglomerativeClustering
Agglo = AgglomerativeClustering(n_clusters=8)
Agglo.fit(principalComponents)
plt.figure(figsize=(20,11))
plt.scatter(tsne_[:, 0],tsne_[:, 1], c=Agglo.labels_,edgecolors='black')
plt.gca().set_aspect('equal', 'datalim')
plt.colorbar(boundaries=np.arange(11)-0.5).set_ticks(np.arange(8))
plt.title('Visualizing DDoS attacks after Agglomerative Clustering', fontsize=24);
plt.show()